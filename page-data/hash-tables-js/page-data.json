{"componentChunkName":"component---src-templates-blog-post-js","path":"/hash-tables-js/","result":{"data":{"site":{"siteMetadata":{"title":"scraggo.com"}},"markdownRemark":{"id":"8e59934a-7dcb-5377-ae8d-73c2d8ed7686","excerpt":"Algorithms and data structures can be intimidating. The goal of this post is to explain some approaches to solving hash table algorithm problems providing clear…","html":"<p>Algorithms and data structures can be intimidating. The goal of this post is to explain some approaches to solving hash table algorithm problems providing clear examples with detailed solution explanations. I’m hoping this will help anyone uninitiated alleviate fears and make bigger strides in conquering these challenging problems.</p>\n<h2>Why Hash Tables?</h2>\n<p>While attending Fullstack Academy, I participated in an algorithms class taught by alumnus Clément Mihailescu, an employee of Google. I found the class to be enlightening and engaging. (I was also star-struck because he works at Google.) He founded <a href=\"https://www.algoexpert.io/\">AlgoExpert</a> which is a top-notch platform for practicing interview problems. I highly recommend it for those who are serious about acing their interviews. I was inspired by the power of hash tables after the class and went on a journey to solve as many hash table problems as I could find.</p>\n<h2>Hash Tables introduction</h2>\n<p>A hash table is a data structure that provides a dictionary-style lookup where a “key” is provided and a “value” is returned. If you’ve worked with object literals in JavaScript (aka associative arrays), you’re familiar with a common implementation of the hash table data structure. Here’s one:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// association: a \"key\" maps to a \"value\"</span>\n<span class=\"token comment\">// in this case, names are keys and their phone numbers are the values:</span>\n<span class=\"token keyword\">const</span> phoneNumberLookup <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string-property property\">'John Smith'</span><span class=\"token operator\">:</span> <span class=\"token string\">'555-123-4567'</span>\n  <span class=\"token string-property property\">'Dan the Man'</span><span class=\"token operator\">:</span> <span class=\"token string\">'555-212-2122'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Let’s see a more algorithmic use for the data structure. This example assigns string characters as the “key” and their frequency count as the “value:”</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// using the Array.prototype.reduce to count the occurrence of characters:</span>\n<span class=\"token comment\">// association: { [character]: number }</span>\n<span class=\"token keyword\">const</span> count <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">'aabbccddeee'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">accumulator<span class=\"token punctuation\">,</span> char</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>char <span class=\"token keyword\">in</span> accumulator<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    accumulator<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    accumulator<span class=\"token punctuation\">[</span>char<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> accumulator<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// result:</span>\n<span class=\"token comment\">// {a: 2, b: 2, c: 2, d: 2, e: 3}</span>\n<span class=\"token comment\">// 'a', 'b', 'c', and 'd' occur 2 times, 'e' occurs 3 times</span></code></pre></div>\n<h3>Hash Functions</h3>\n<p>JavaScript provides us this data structure without us having to know how it works. I want to go a little behind the scenes into the hash function algorithm, its dangers, benefits, and drawbacks.</p>\n<p>The process of looking up a value from a given key is particularly clever (in my opinion):</p>\n<ol>\n<li>A key is provided as input to a hash function.</li>\n<li>The hash algorithm converts this key into an integer.</li>\n<li>This integer is an array index of a location in memory.</li>\n<li>The location contains the value data that corresponds with the given key.</li>\n</ol>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/Hash_table_4_1_1_0_0_1_0_LL.svg/480px-Hash_table_4_1_1_0_0_1_0_LL.svg.png\" alt=\"hash table - wikipedia\"></p>\n<p>Example: “Lisa Smith” goes through a hash function and results in array index <code class=\"language-text\">1</code>. “Sam Doe” goes through a hash function and results in array index <code class=\"language-text\">4</code>. Their respective data is stored at their respective array indices.</p>\n<p>If you’re a little wary of the image above where both “John Smith” and “Sandra Dee” point to the same address, you’re not alone. If two or more different hashed keys resulted in the same array index, those are considered “collisions.” Not accounting for collisions is dangerous because we risk losing data. To prevent data loss, the hashing algorithm must have collision resolving methods and (ideally) prevent collisions in the first place. For a data loss example, let’s say both <code class=\"language-text\">key1</code> and <code class=\"language-text\">key2</code> when hashed resulted in array index <code class=\"language-text\">0</code>. Then, data for <code class=\"language-text\">key1</code> is written to that index. Then, data for <code class=\"language-text\">key2</code> is written to that index. Finally, if I want the data from <code class=\"language-text\">key1</code>, it’ll have been overwritten by the data of <code class=\"language-text\">key2</code>! No good.</p>\n<p>Let’s talk “Big O.” In terms of time complexity, writing and retrieving data using a hash table are O(1) operations. That’s amazing in terms of efficiency! Less optimal is sorting the data, you’re better off using a different data structure if that’s important for your use case.</p>\n<p>I encourage you to check out the articles below for more on “Big O” and in-depth hash table lessons.</p>\n<p>Big O Notation:</p>\n<ul>\n<li><a href=\"https://www.freecodecamp.org/news/big-o-notation-explained-with-examples/\">Big O Notation Explained with Examples</a></li>\n<li><a href=\"http://bigocheatsheet.com/\">Big-O Algorithm Complexity Cheat Sheet @ericdrowell</a></li>\n</ul>\n<p>Hash Tables:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Hash_function\">Hash function | Wikipedia</a></li>\n<li><a href=\"https://javascript.plainenglish.io/algorithm-in-javascript-hash-table-7b0464d2b81b\">Algorithms in JavaScript: Hash Tables | by Rohan Paul | JavaScript in Plain English</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/hashing-set-1-introduction/\">Hashing GeeksforGeeks</a></li>\n<li><a href=\"https://www.interviewcake.com/concept/java/hash-map\">Hash Table Map Data Structure - Interview Cake</a></li>\n</ul>\n<h3>Coding Challenge Sites: Leetcode, Hackerrank, Codewars, and more</h3>\n<p>There are many great “code challenge” websites to practice at computer science problems. When I wanted to work more with hash tables, I discovered that <a href=\"https://leetcode.com/\">LeetCode</a> has a tagging system which links to 81 hash table problems!</p>\n<ul>\n<li><a href=\"https://leetcode.com/tag/hash-table/\">Hash Table - LeetCode</a></li>\n</ul>\n<p>Other great sites for coding challenges:</p>\n<ul>\n<li><a href=\"https://www.hackerrank.com/\">HackerRank</a> my general favorite. The “Data Structures” and “Algorithms” tracks are phenomenal. I also enjoyed “10 Days of JavaScript.”</li>\n<li><a href=\"https://www.codewars.com/\">Codewars</a> - has an excellent community and platform, as well as some very fun problems.</li>\n</ul>\n<h2>Summary of Approaches</h2>\n<p>After solving around 6 problems of various difficulty on LeetCode, I observed some general principles and forms:</p>\n<ul>\n<li>Hash tables allow for very fast, O(1), lookups. If my solution to a problem was “timing out,” I was probably over-using array methods.</li>\n<li>Nested <code class=\"language-text\">for</code> loops (which have O(n^2) time efficiency) can often be alleviated with hash tables.</li>\n<li>It’s often necessary to make two passes through an array to gather the hash table data to allow for complete processing.</li>\n<li>It’s sometimes possible to make a single pass if by the end of the pass, you have all the data you need for processing.</li>\n</ul>\n<p>Javascript objects (what I’ve used for hash tables) are extremely versatile. I was able to implement them with the following patterns:</p>\n<ul>\n<li>a “map” of one data type to another: <code class=\"language-text\">{a: 'dog'}</code></li>\n<li>the “visited” pattern: <code class=\"language-text\">{1: true}</code>. You can also use a <code class=\"language-text\">Set</code> for this.</li>\n<li>the “count” or “accumulator” pattern: <code class=\"language-text\">{a: 2, b: 12}</code>. This can be implemented with <code class=\"language-text\">.reduce()</code> or a simple <code class=\"language-text\">for</code> loop.</li>\n</ul>\n<h2>Word Pattern (tagged as ‘Easy’)</h2>\n<p>Link to problem &#x26; description: <a href=\"https://leetcode.com/problems/word-pattern/description/\">Word Pattern - LeetCode</a></p>\n<p>Basic Gist: If a pattern (like ‘abba’) matches an input string (like ‘dog cat cat dog’) then it’s a match. (‘dog cat cat fish’ wouldn’t be a match.)</p>\n<p>My Solution Stats:\n<em>Status: Accepted. 33 / 33 test cases passed. Runtime: 48 ms</em></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/**\n * @param {string} pattern\n * @param {string} str\n * @return {boolean}\n */</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">wordPattern</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">pattern<span class=\"token punctuation\">,</span> str</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pattern <span class=\"token operator\">===</span> <span class=\"token string\">''</span> <span class=\"token operator\">||</span> str <span class=\"token operator\">===</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> arrStr <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arrStr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">!==</span> pattern<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> patternHash <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> wordHash <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arrStr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>patternHash<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>wordHash<span class=\"token punctuation\">[</span>arrStr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// add the pattern letter to hash table, mapped to current word</span>\n      patternHash<span class=\"token punctuation\">[</span>pattern<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arrStr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// make sure current word is accounted for</span>\n      wordHash<span class=\"token punctuation\">[</span>arrStr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// check if the word in the pattern hash matches the current word</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>patternHash<span class=\"token punctuation\">[</span>pattern<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> arrStr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Explanation:</p>\n<ul>\n<li>the first 3 lines are guards against invalid input and split the input <code class=\"language-text\">str</code> into an array which was separated by spaces.</li>\n<li><code class=\"language-text\">patternHash</code> and <code class=\"language-text\">wordHash</code> will keep track of slightly different things. (I’ll explain as I go.)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// patternHash example: { a: 'dog', b: 'cat' }</span>\n<span class=\"token comment\">// wordHash example: { dog: true, cat: true }</span></code></pre></div>\n<ul>\n<li>we use a <code class=\"language-text\">for</code> loop to iterate over the entire input string as array.</li>\n<li>\n<p>the first <code class=\"language-text\">if</code> block checks 2 things have NOT happened yet:</p>\n<ol>\n<li>if we’ve mapped a word to a letter in the pattern string.</li>\n<li>if we’ve accounted for the current word - which is <code class=\"language-text\">arrStr[i]</code>.</li>\n<li>if neither has happened, we can safely initialize both hashes. (as described above).</li>\n</ol>\n</li>\n<li><code class=\"language-text\">else</code> block: now is the moment of truth. If <code class=\"language-text\">patternHash[pattern[i]]</code> doesn’t match up with <code class=\"language-text\">arrStr[i]</code>, we can definitively <code class=\"language-text\">return false</code>. We don’t have an exact match of pattern to words.</li>\n<li>finally, if the <code class=\"language-text\">for</code> loop has completed, we can safely <code class=\"language-text\">return true</code>. We have a match!</li>\n</ul>\n<p>Reflection: This certainly works, but I can probably do this with only one hash table. <code class=\"language-text\">{dog: true}</code> doesn’t have extra meaningful data and between my two hashes, I store each word twice.</p>\n<h2>Two Sum (tagged as ‘Easy’)</h2>\n<p>Link to problem &#x26; description: <a href=\"https://leetcode.com/problems/two-sum/description/\">Two Sum - LeetCode</a></p>\n<p>Basic Gist: Given an array of integers, return indices of the two numbers such that they add up to a specific target. (target could be 9, for example.)</p>\n<p>My Solution Stats:\n<em>19 / 19 test cases passed. Status: Accepted. Runtime: 84 ms</em></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">twoSum</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nums<span class=\"token punctuation\">,</span> target</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> hashed <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  nums<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n<span class=\"token punctuation\">,</span> i</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>hashed<span class=\"token punctuation\">.</span><span class=\"token function\">hasOwnProperty</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      hashed<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      hashed<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>hashed<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> hashedKeys <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>hashed<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> subtractor <span class=\"token operator\">=</span> target <span class=\"token operator\">-</span> <span class=\"token operator\">+</span>hashedKeys<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>subtractor <span class=\"token keyword\">in</span> hashed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">let</span> check <span class=\"token operator\">=</span> hashed<span class=\"token punctuation\">[</span>hashedKeys<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>check<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>check<span class=\"token punctuation\">,</span> hashed<span class=\"token punctuation\">[</span>subtractor<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> check<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Explanation:</p>\n<ul>\n<li>I begin by initializing a hash object to store the numbers as unique keys. For the values, each number key initially maps to its index. If there are multiples of a number key, I store an array of the indices. Each value can only be used once, so this prepares for the solution format (which asks for an array of two indices).</li>\n<li><code class=\"language-text\">hashedKeys</code> is the hash converted to an array of its keys.</li>\n<li>the <code class=\"language-text\">for</code> loop iterates over all the numbers in the array. Everything below runs inside the loop.</li>\n<li>the <code class=\"language-text\">subtractor</code> is the number we’re looking for to add with the current number to see if it adds up to the <code class=\"language-text\">target</code>. I saved it in a variable for easier readability going forward.</li>\n<li>Now for the main <code class=\"language-text\">if</code> block which checks if the <code class=\"language-text\">subtractor</code> is present in the hash.</li>\n<li>\n<p>the <code class=\"language-text\">check</code> variable will be type checked.</p>\n<ul>\n<li>If we have a number, that means it’s unique and we can return in the array format requested.</li>\n<li>If it’s an array, that means the values are equivalent, and we can return what we initially stored. I do a slice to ensure that it’s the correct length.</li>\n</ul>\n</li>\n</ul>\n<p>Reflection: I worked on this problem 5 months before working on it recently. I unknowingly created an O(n^2) algorithm by using <code class=\"language-text\">indexOf</code> to check the entire array sliced at each index as I iterated over it. The runtime was 548 ms (more than 5 times slower than the hash solution.) I think I can improve my hash solution by implementing it without <code class=\"language-text\">Object.keys(hash)</code>. I can’t actually explain (at the moment) why I used that, and didn’t use <code class=\"language-text\">nums[i]</code>.</p>\n<p>Note: I used the “Two Pass” solution. Read more about that and other solutions here: <a href=\"https://leetcode.com/articles/two-sum/\">Two Sum - LeetCode Articles</a>. It may be locked until you’ve solved it yourself.</p>\n<h2>Single Number (tagged as ‘Easy’)</h2>\n<p>Link to problem &#x26; description: <a href=\"https://leetcode.com/problems/single-number/description/\">Single Number - LeetCode</a></p>\n<p>Basic Gist: Given an array of integers, every element appears twice except for one. Find that single one.</p>\n<p>My Solution Stats:\n<em>15 / 15 test cases passed. Status: Accepted. Runtime: 84 ms</em></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/**\n * @param {number[]} nums\n * @return {number}\n */</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">singleNumber</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nums</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> once <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  nums<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>once<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      once<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      once<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>once<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Explanation:</p>\n<ul>\n<li>I realized I could use a <code class=\"language-text\">Set</code> to handle storing unique numbers and for fast lookup.</li>\n<li>\n<p>Using a <code class=\"language-text\">forEach</code> loop:</p>\n<ul>\n<li>The first time a number has been seen, I store it in the <code class=\"language-text\">once</code> set.</li>\n<li>If the number had been seen before, I delete it from the <code class=\"language-text\">once</code> set.</li>\n</ul>\n</li>\n<li>Assuming our inputs are valid, we return the only element in the <code class=\"language-text\">once</code> set. We get to it by converting it to an array with <code class=\"language-text\">Array.from()</code> and getting the <code class=\"language-text\">[0]</code> element.</li>\n</ul>\n<p>Reflection: Initially, I created two hashes to make sure the algorithm was running correctly. I realized I could use a <code class=\"language-text\">Set</code> later and and simply delete the <code class=\"language-text\">num</code> entry in <code class=\"language-text\">once</code>, without storing it in <code class=\"language-text\">twice</code>. Oddly enough, my runtime went from 64ms to 84ms with the <code class=\"language-text\">Set</code> implementation. Maybe objects are optimized to run more quickly than sets (?)</p>\n<p>Note: there is a very nice solution explanation here: <a href=\"https://leetcode.com/articles/single-number/\">Single Number - LeetCode Articles</a>. It may be locked until you’ve solved it yourself.</p>\n<h2>Set Mismatch (tagged as ‘Easy’)</h2>\n<p>Link to problem &#x26; description: <a href=\"https://leetcode.com/problems/set-mismatch/description/\">Set Mismatch - LeetCode</a></p>\n<p>Basic Gist: You have to find where “an error occurred.” Any given input will have a number missing and a number duplicated. Example: <code class=\"language-text\">[1,2,2,4]</code></p>\n<p>My Solution Stats:\n<em>49 / 49 test cases passed. Status: Accepted. Runtime: 84 ms</em></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/**\n * @param {number[]} nums\n * @return {number[]}\n */</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">findErrorNums</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nums</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> visited <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> max <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> current <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>visited<span class=\"token punctuation\">[</span>current<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      visited<span class=\"token punctuation\">[</span>current<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// current is the duplicated number</span>\n      result<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> current<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>current <span class=\"token operator\">></span> max<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      max <span class=\"token operator\">=</span> current<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  current <span class=\"token operator\">=</span> max<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>current <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> oneBefore <span class=\"token operator\">=</span> current <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>visited<span class=\"token punctuation\">[</span>oneBefore<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// oneBefore is the skipped number</span>\n      result<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> oneBefore<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    current<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>result<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    result<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> max <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Explanation:</p>\n<ul>\n<li>\n<p>This problem was difficult to optimize because the input numbers were not necessarily sorted. There were a few short cases that needed to be accounted for. Note: <code class=\"language-text\">result[0]</code> is the duplicated number and <code class=\"language-text\">result[1]</code> is the missing number.</p>\n<ul>\n<li>input <code class=\"language-text\">[2,2]</code> expected <code class=\"language-text\">[2,1]</code> output.</li>\n<li>input <code class=\"language-text\">[1,1]</code> expected <code class=\"language-text\">[1,2]</code> output.</li>\n<li>I’ll describe further down how I accounted for this.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">visited</code> is our initialized hash. We’ll set a given number as a key and ‘true’ as the value to keep track of us visiting the number.</li>\n<li><code class=\"language-text\">result</code> is an array initialized with 2 <code class=\"language-text\">null</code> values. This way, I was forcing myself to update it without having an accidental solution.</li>\n<li><code class=\"language-text\">max</code> is the highest number in the array. I wanted to avoid sorting, so the highest number in the array would be where I search from to find the missing number. More below.</li>\n<li>\n<p>the <code class=\"language-text\">for</code> loop iterates over all the numbers.</p>\n<ul>\n<li>If the number isn’t in <code class=\"language-text\">visited</code>, add it to it.</li>\n<li>If the number is in <code class=\"language-text\">visited</code>, it’s the duplicated number. We save it as <code class=\"language-text\">result[0]</code>.</li>\n<li>I check all numbers and store it in <code class=\"language-text\">max</code> if it’s the highest so far.</li>\n</ul>\n</li>\n<li>\n<p>The <code class=\"language-text\">while</code> loop begins at <code class=\"language-text\">max</code> and traverses downward.</p>\n<ul>\n<li><code class=\"language-text\">oneBefore</code> is our search, it’s simply the current number - 1.</li>\n<li>If we don’t see <code class=\"language-text\">oneBefore</code> in <code class=\"language-text\">visited</code>, it’s the missing number! We can assign it to our result and return it.</li>\n<li>If we do see it, we simply go down and try <code class=\"language-text\">current--</code>.</li>\n</ul>\n</li>\n<li>After this <code class=\"language-text\">while</code> loop, we now account for the case where both numbers are 1. We know that <code class=\"language-text\">result[1]</code> should be one number higher than max.</li>\n</ul>\n<p>Reflection: I feel like the efficiency of the algorithm is quite good. I only store what’s necessary. Keeping track of the edge cases was a bit cumbersome for me. I’m sure there’s a graceful way to do it without the final check that I do.</p>\n<p>Official Solution: <a href=\"https://leetcode.com/articles/set-mismatch/\">Set Mismatch - LeetCode Articles</a></p>\n<ul>\n<li>Note: It may be locked until you try to solve it!</li>\n</ul>\n<h2>Longest Harmonious Subsequence (tagged as ‘Easy’)</h2>\n<p>Link to problem &#x26; description: <a href=\"https://leetcode.com/problems/longest-harmonious-subsequence/description/\">Longest Harmonious Subsequence - LeetCode</a></p>\n<p>Basic Gist: Return the length of the longest sequence of 2 unique numbers which are consecutive. Example subsequences: <code class=\"language-text\">[3,2,2,2,3]</code>, <code class=\"language-text\">[3,2,3,2,3]</code>, <code class=\"language-text\">[3,3,3,2,2,2]</code>. (Other numbers in between aren’t counted.) (This one’s a bit difficult to summarize, so check out the problem description.)</p>\n<p>My Solution Stats:\n<em>201 / 201 test cases passed. Status: Accepted. Runtime: 108 ms</em></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/**\n * @param {number[]} nums\n * @return {number}\n */</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">findLHS</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nums</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> hash <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> current<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> i<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> max <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> maxCheck1 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> maxCheck2 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    current <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>current <span class=\"token keyword\">in</span> hash<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      hash<span class=\"token punctuation\">[</span>current<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      hash<span class=\"token punctuation\">[</span>current<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">[</span>current <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      maxCheck1 <span class=\"token operator\">=</span> hash<span class=\"token punctuation\">[</span>current<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> hash<span class=\"token punctuation\">[</span>current <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">[</span>current <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      maxCheck2 <span class=\"token operator\">=</span> hash<span class=\"token punctuation\">[</span>current<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> hash<span class=\"token punctuation\">[</span>current <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    max <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>max<span class=\"token punctuation\">,</span> maxCheck1<span class=\"token punctuation\">,</span> maxCheck2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> max<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Explanation:</p>\n<ul>\n<li>The <code class=\"language-text\">hash</code> in this problem stores a number as unique key and the number of times it occurs as the value.</li>\n<li>I initialized all the variables outside of the loop. It isn’t necessary to do it this way, I just felt like it.</li>\n<li>\n<p>The <code class=\"language-text\">for</code> loop is the main scene of this algorithm. I iterate over all of the numbers in the input array.</p>\n<ul>\n<li>The current number is stored in the <code class=\"language-text\">current</code> variable.</li>\n<li>The first <code class=\"language-text\">if</code> block checks if the current number is in the hash table. If so, we increase it’s value by 1. If not, we initialize it to be 1.</li>\n<li>The second <code class=\"language-text\">if</code> block checks if the current number plus 1 is in the hash table. If so, we store the total number of occurrences of <code class=\"language-text\">current</code> and <code class=\"language-text\">current + 1</code> in the <code class=\"language-text\">maxCheck1</code> variable. (This will be used soon below.)</li>\n<li>The third and final <code class=\"language-text\">if</code> block checks if the current number minus 1 is in the hash table. If so, we store the total number of occurrences of <code class=\"language-text\">current</code> and <code class=\"language-text\">current - 1</code> in the <code class=\"language-text\">maxCheck2</code> variable. (This will be used soon below.)</li>\n<li><code class=\"language-text\">max</code> is the maximum of <code class=\"language-text\">max</code>, <code class=\"language-text\">maxCheck1</code>, and <code class=\"language-text\">maxCheck2</code>. <code class=\"language-text\">max</code> represents the length of the longest sequence.</li>\n</ul>\n</li>\n</ul>\n<p>Reflection: I first implemented this solution in 2 passes. After seeing the official solution, I decided to wrangle mine into the single pass version. There’s even more I could do to clean it up, but I’m pretty happy with it.</p>\n<p>Official Solution: <a href=\"https://leetcode.com/problems/longest-harmonious-subsequence/solution/\">Longest Harmonious Subsequence - LeetCode</a></p>\n<ul>\n<li>Note: It may be locked until you try to solve it!</li>\n</ul>\n<h2>Parting Notes</h2>\n<p>I’m no expert at algorithms in general, but I’m definitely enjoying learning about them. The more I learn, the more I’m able to visualize different approaches to problems and begin to optimize my solutions. Please contact me below if you have comments about this article and/or suggestions for improvement.</p>\n<p><em>This “enrichment piece” was written as a student at Fullstack Academy.</em></p>","fields":{"slug":"/hash-tables-js/"},"frontmatter":{"author":"Dave Cohen","categories":["tech"],"date":"February 20, 2018","description":null,"tags":["javascript","computer science"],"title":"Tackling Hash Table Problems in JavaScript"}}},"pageContext":{"slug":"/hash-tables-js/","previous":{"fields":{"slug":"/now-attending-fullstack/"},"frontmatter":{"tags":["coding bootcamps","javascript"],"title":"Now Attending: Fullstack Academy","type":"post"}},"next":{"fields":{"slug":"/reflections-coding-bootcamp/"},"frontmatter":{"tags":["coding bootcamps","javascript"],"title":"Reflections From a Coding Bootcamp Graduate","type":"post"}}}},"staticQueryHashes":["3159585216","63159454"]}